---
title: 'Programming in Python: Lecture 2'
author: "Carolyn Jane Anderson"
date: "9/15/2017"
output: html_document
---

```{r,echo=FALSE}
library(knitr)
opts_chunk$set(engine = 'python',engine.path="/usr/local/bin/python2")
```

Today we're going to cover input and output, functions, and dictionaries.

<h3>Input and Output</h3>

In our last class, we briefly saw how to open a file and read its contents. We can use the same file() function to write the results of a program to a file. 

```{python}
f = open('results.txt', 'w') #Remember to adjust the name/location of the file for your own computer!
introduction = "Hello!\nMy name is Matilda."
f.write(introduction)
```

This creates a file in my working directory called results.txt, and writes our string to that file. Opening a file with option 'w' will override an existing file if there is one. You can use option 'a' to append to an existing file. You can also use option 'r+' to open a file for reading and writing.

<h4>Reading user input</h4>

We know how to read in data from a file. That's great! But what if we want to interact with the user in real time?

```{python, eval=FALSE}
name = raw_input("Please choose a cat name:\n")

if (name != "Captain Haddock") and (name != "Calvin"):
  print "That's not my cat!"
else:
  print "That is my cat!"
```

If we save this as a python file and run it, it will prompt the user for a string, and then output whether or not the string is one of my cats' names.

<h3>More about control statements</h3>

Let's consider expanding our program a little bit to give the user three guesses. One option would be to use a for loop to iterate through the code three times. This requires us to figure out a way to not repeat the prompt if the user has already correctly guessed one of my cats.

One option is to use a variable to store whether or not the user has already succeeded. At the top of the for loop, we'll check to see if the user has already guessed correctly, and if so, we won't do anything.

```{python,eval=FALSE}

success = False
for i in range(0,3):
  if success == False:                                        #Has the user succeeded yet?
    name = raw_input("Please choose a cat name:\n")
    if (name != "Captain Haddock") and (name != "Calvin"):
      print "That's not my cat!"
    else:
      print "That is my cat!"
      success = True                                          #Set the value of success to True since the user has guessed correctly
```

This is much easier to read. We can make it even more efficient however, by using *break* to end the for loop early if the user guesses correctly.

```{python,eval=FALSE}

for i in range(0,3):                                       #Has the user succeeded yet?
  name = raw_input("Please choose a cat name:\n")
  if (name != "Captain Haddock") and (name != "Calvin"):
    print "That's not my cat!"
  else:
    print "That is my cat!" 
    break
```

But what if we don't know how many chances we want to give the user? What if we want the program to run until they guess correctly?

<h4>While loops</h4>

There's another kind of control loop in Python that makes this easy. It's called a while loop.

```{python,eval=FALSE}
while:
  name = raw_input("Please choose a cat name:\n")
  if (name != "Captain Haddock") and (name != "Calvin"):
    print "That's not my cat!"
  else:
    print "That is my cat!" 
    break
```

Question: What happens if we forget to put in the break statement?

<h3>Functions</h3>

Let's move on from our cat guessing game to a more realistic task. We're going to write a program that prompts the user for a list of words and a block of text, and counts how many times each of the words appears in the text (that is, count the *tokens*).

Let's break this problem down into tasks:

1. Ask the user for the name of the text file.
2. Ask the user for a list of words.
3. Count how many times each word appears in the text.
4. Report the results to the user.

That seems pretty simple! The first thing to ask ourselves, though, is when the program should quit. Should it only run once? Or should it wait until the user asks it to quit?

Let's write the program so that it runs until the user types "quit". We can modify our task list slightly to reflect this.

1. Give the user two choices: (1) count words or (2) quit
2. Ask the user for the name of the text file.
3. Ask the user for a list of words.
4. Count how many times each word appears in the text.
5. Report the results to the user.

Okay, let's tackle the first task first. We'll write a while loop that asks the user to pick an option, and quits if that option is 3.

```{python, eval=FALSE}

quit = False
while quit == False:	
  print "Please pick an option: "
	print "1. Run word count"
	print "2. Quit"
	choice = int(raw_input("Your choice is: ")) #Remember to convert the input to an integer if you're comparing it to an integer!
	if choice == 2:
		print "Thanks for playing!"
		quit = True
```

So far so good. Our program quits on demand, but otherwise it doesn't do anything.

If the user picks Option 1, we need to ask them for a file name.

```{python, eval=FALSE}

quit = False
while quit == False:	
  print "Please pick an option: "
	print "1. Run word count"
	print "2. Quit"
	choice = int(raw_input("Your choice is: ")) #Remember to convert the input to an integer if you're comparing it to an integer!
	if choice == 2:
		print "Thanks for playing!"
		quit = True
	else:
	  f = raw_input("File name: ")
	  wordString = raw_input("Words to count: ")
	    
```

Okay, we've handled all the user interface stuff. Now for the substance of our program. We've already written code that compares the guess to the list of cats. But it would be really nice if we didn't have to paste that code into our while loop, which is already fairly long. If we write it inside a function, we can make our code tidier, and also easier to change if we decide we want to swap our the is-it-my-cat game for something more interesting.

Here's how we define a function in Python:

```{python}

def isitmycat(guess,cats): 	#We name the arguments to the function in the parentheses
	if guess in cats:
		print "That's my cat!"
	else:
		print "That's not my cat."

goodguess = "Calvin"
badguess = "Matilda"
catlist = ["Captain Haddock","Calvin"]

isitmycat(goodguess,catlist)
isitmycat(badguess,catlist)
```

Our isitme() function is going to be very similar, but we'll compare the guess against a string: my name.

```{python}

def isitme(guess,name): 	#We name the arguments to the function in the parentheses
	if guess == name:
		print "That's me!"
	else:
		print "That's not me."
		
###################################

itsme = "Carolyn"
notme = "Matilda"
isitme(notme,itsme)
```

I've used the line of # characters to demarcate the end of the function (of course, the indentation level also shows us the end). Since # is the character used for comments, you can break up long programs into chunks this way.

Now we have all the pieces to write our game.

```{python, eval=FALSE}
mycats = ["Calvin","Captain Haddock"] #If we define our list here, it's easy to change later
me = "Carolyn"

###################################

def isitmycat(guess,cats): 	#We name the arguments to the function in the parentheses
	if guess in cats:
		print "That's my cat!"
	else:
		print "That's not my cat."

###################################

def isitme(guess,name): 	#We name the arguments to the function in the parentheses
	if guess == name:
		print "That's me!"
	else:
		print "That's not me."
		
###################################

print "Welcome!"

quit = False				#Initialize quit to False
while quit == False:		#Stop when isitmycat() returns True
	print "Please pick an option: "
	print "1. Play is-it-my-cat"
	print "2. Play is-it-me"
	print "3. Quit"
	choice = int(raw_input("Your choice is: "))	#Convert the input to an integer since we're comparing it to an integer!
	if choice == 3:
		print "Thanks for playing!"
		quit = True
	else:
		guess = raw_input("Your guess is: ")
		if choice == 1:
			isitmycat(guess,mycats)
		else:
			isitme(guess,me)

```

It's conventional to put the body of your program inside a function called *main*.

```{python, eval=FALSE}

def main():
  mycats = ["Calvin","Captain Haddock"]
  me = "Carolyn"
  
  print "Welcome!"

  quit = False				#Initialize quit to False
  while quit == False:		#Stop when isitmycat() returns True
	  print "Please pick an option: "
  	print "1. Play is-it-my-cat"
	  print "2. Play is-it-me"
  	print "3. Quit"
  	choice = int(raw_input("Your choice is: "))	#Convert the input to an integer since we're comparing it to an integer!
  	if choice == 3:
	  	print "Thanks for playing!"
	  	quit = True
  	else:
		  guess = raw_input("Your guess is: ")
		  if choice == 1:
		  	isitmycat(guess,mycats)
	  	else:
		  	isitme(guess,me)
  
###################################

def isitmycat(guess,cats): 	#We name the arguments to the function in the parentheses
	if guess in cats:
		print "That's my cat!"
	else:
		print "That's not my cat."

###################################

def isitme(guess,name): 	#We name the arguments to the function in the parentheses
	if guess == name:
		print "That's me!"
	else:
		print "That's not me."
		
###################################

main()
```
